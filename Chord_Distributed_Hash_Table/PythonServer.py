#!/usr/bin/env python
import glob
import sys
import hashlib
import socket

# these two lines are mandatory to include
sys.path.append('gen-py')
sys.path.insert(0, glob.glob('/home/yaoliu/src_code/local/lib/lib/python2.7/site-packages')[0])

# import from code generated by IDL compiler (thrift)
from chord import FileStore
from chord.ttypes import SystemException, RFileMetadata, RFile, NodeID

# importing python thrift libraries
from thrift.transport import TSocket
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol
from thrift.server import TServer

'''
Implement the basic functions of the Chord distributed hash table
'''


class FileStoreHandler:
    #dictionary to store file key and metadata
    file_info = {}
    #finger table - DHT of chord system - array
    finger_table = []

    # constructor
    def __init__(self, port):
        self.log = {}
        self.serverNode = NodeID()
        self.serverNode.ip = str(socket.gethostbyname(socket.gethostname()))
        self.serverNode.id = hashlib.sha256(str(socket.gethostbyname(socket.gethostname()) + ":" + port).encode()).hexdigest()
        self.serverNode.port = int(port)
        print("Server Host Name is - ", socket.gethostname())
        print("Server IP address (Host Address) is - ", self.serverNode.ip)
        print("Server Port is - ", str(self.serverNode.port))
        print("Server hash - ", self.serverNode.id)
        self.chordSystemSize = pow(2, 256)

    # to check if finger table for server is set properly
    def checkFingerTable(self):
        check_fingertable = True
        # if length is o - raise exception
        if (len(self.finger_table) == 0):
            systemException = SystemException()
            systemException.message = "Finger table not set properly at server side"
            raise systemException
            return False
        return check_fingertable

    '''
        Given a filename and contents, function writes file to server
        Meta-information, stored at the server side is as follows -
        - File name
        - Version
        - File content
        - File content hash (SHA-256 hash of the file content)
        
        Data stucture used - Dictionary - 
        - key - hash of file name
        - value - tuple of meta information
         
    '''

    def writeFile(self, rFileNodeIn):
        hash_object = hashlib.sha256((rFileNodeIn.meta.filename).encode()).hexdigest()
        # print("\nWrite - " + rFileNodeIn.meta.filename + ", hash code = " + hash_object)
        fileServerNodeSucc = self.findSucc(hash_object)
        # print("\nWrite - fileServerNodeSucc = " + fileServerNodeSucc.id)

        if (fileServerNodeSucc.id != self.serverNode.id):
            systemException = SystemException()
            systemException.message = ("File not owned by Server " + self.serverNode.ip +
                                       ":" + str(self.serverNode.port) + "\n")
            raise systemException

        if hash_object not in self.file_info:
            self.file_info[hash_object] = (rFileNodeIn.meta.filename, 0, rFileNodeIn.content, hashlib.sha256((rFileNodeIn.content).encode()).hexdigest())
        else:
            version = self.file_info[hash_object][1]
            self.file_info[hash_object] = (rFileNodeIn.meta.filename, version + 1, rFileNodeIn.content, hashlib.sha256((rFileNodeIn.content).encode()).hexdigest())

    '''
        File with a given name exists on the server, both the contents and meta-information should be returned.
        A SystemException is thrown in below cases - 
        - If File not own by Server i.e. the server is not the file’s successor
        - If File Not Found on Server
    '''

    def readFile(self, filenameIn):
        rFile = RFile()
        try:
            hash_object = hashlib.sha256(filenameIn.encode()).hexdigest()
            # Find the successor of file
            fileServerNode = self.findSucc(hash_object)

            # If successor of file is not same server to which client has requested file - SystemException is thrown
            if (fileServerNode.id != self.serverNode.id):
                systemException = SystemException()
                systemException.message = ("File not owned by Server " + self.serverNode.ip +
                                           ":" + str(self.serverNode.port) + "\n")
                raise systemException

            # If successor of file is same server to which client has requested file - Request served
            rFileMetadata = RFileMetadata()
            if (self.file_info.get(hash_object) != None):
                rFileMetadata.filename = filenameIn
                rFileMetadata.version = self.file_info.get(hash_object)[1] + 1
                rFileMetadata.contentHash = self.file_info.get(hash_object)[3]

                rFile.meta = rFileMetadata
                rFile.content = self.file_info.get(hash_object)[2]
            else:
                systemException = SystemException()
                systemException.message = ("\nFile " + filenameIn + " Not Found")
                raise systemException

        except IOError as e:
            systemException = SystemException()
            systemException.message = "IO Exception in read file"
            raise systemException

        return rFile

    '''
        Sets the current node’s fingertable to the fingertable provided in the argument of the function
        This will be called by init program which will return finger_table
    '''
    def setFingertable(self, node_list_in):
        self.finger_table = node_list_in
        '''for l in self.finger_table:
            print(l.id + ' ' + l.ip + ' ' + str(l.port))'''

    '''
        Returns the closest DHT node that follows the current node in the Chord key space.
        It simply returns the node’s first fingertable entry.
        A SystemException should be thrown if no fingertable exists for the current node.
    '''
    def getNodeSucc(self):
        if (self.checkFingerTable()):
            return self.finger_table[0]

    '''
        Given an identifier in the DHT’s key space, this function returns the DHT node that immediately
        precedes the id. This preceeding node is the first node in the counter-clockwise direction in the Chord key
        space. A SystemException is thrown if no fingertable exists for the current node.
    '''

    def findPred(self, keyIn):
        if (self.checkFingerTable()):
            nextNode = self.getNodeSucc()
            nkey = int(keyIn, 16)
            nServerNodeId = int(self.serverNode.id, 16)
            nServerNodeSuccessorId = int(nextNode.id, 16)

            # if nServerNodeSuccessorId is smaller than current node then need to increase value if successorId value by chord size
            if (nServerNodeSuccessorId < nServerNodeId):
                nServerNodeSuccessorId += self.chordSystemSize

            # if servernodeid is greater than key, need to add chord size into key - as chord is circular
            if nServerNodeId > nkey:
                nkey += self.chordSystemSize

            # if key is between servernode and servernode's successor, need to return current servernode as predecessor for key
            if nkey > nServerNodeId and nkey <= nServerNodeSuccessorId:
                return self.serverNode

            # if key is between servernode and servernode's successor, check finger table in reverse order to check for predecessor node
            if not (nkey > nServerNodeId and nkey <= nServerNodeSuccessorId):
                # find closest predecessor node of key
                closestPrecedingNode = self.findClosestPrecedingFinger(keyIn)

                # if predecessor is current servernode - return servernode, otherwise make RPC to server to check it's finger table
                if closestPrecedingNode.id == self.serverNode.id:
                    return self.serverNode

                # Make socket
                newTransport = TSocket.TSocket(closestPrecedingNode.ip, closestPrecedingNode.port)
                # Buffering is critical. Raw sockets are very slow
                newTransport = TTransport.TBufferedTransport(newTransport)
                # Wrap in a protocol
                newProtocol = TBinaryProtocol.TBinaryProtocol(newTransport)
                # Create a client to use the protocol encoder
                newClient = FileStore.Client(newProtocol)
                # Connect!
                newTransport.open()

                return newClient.findPred(keyIn)
        return self.serverNode

    # traverse in finger table in reverse order to get closest preceding server which is avaialble in finger table for key
    def findClosestPrecedingFinger(self, keyIn):
        nkey = int(keyIn, 16)
        nServerNodeId = int(self.serverNode.id, 16)

        if nServerNodeId > nkey:
            nkey += self.chordSystemSize

        for i in range(255, -1, -1):
            nFingerTableId = int(self.finger_table[i].id, 16)
            if (nFingerTableId < nServerNodeId):
                nFingerTableId += self.chordSystemSize

            if nFingerTableId > nServerNodeId and nFingerTableId < nkey and self.finger_table[i].id != self.serverNode.id:
                return self.finger_table[i]

        # print("entry not found in finger table")
        return self.serverNode

    '''
        Given an identifier in the DHT’s key space, returns the DHT node that owns the id. 
        This function is implemented in two parts:
        1. The function findPred is invoked to discover the DHT node that precedes the given id
        2. The function getNodeSucc is invoked to find the successor of this predecessor node
    '''

    def findSucc(self, keyIn):
        if (self.checkFingerTable()):
            predNode = self.findPred(keyIn)
            # print("predNode = ", predNode.id)
            if predNode.id == self.serverNode.id:
                return self.getNodeSucc()
            # Make socket
            newTransport = TSocket.TSocket(predNode.ip, predNode.port)
            # Buffering is critical. Raw sockets are very slow
            newTransport = TTransport.TBufferedTransport(newTransport)
            # Wrap in a protocol
            newProtocol = TBinaryProtocol.TBinaryProtocol(newTransport)
            # Create a client to use the protocol encoder
            newClient = FileStore.Client(newProtocol)
            # Connect!
            newTransport.open()

        return newClient.getNodeSucc()


if __name__ == '__main__':
    handler = FileStoreHandler(sys.argv[1])
    processor = FileStore.Processor(handler)
    transport = TSocket.TServerSocket(port=int(sys.argv[1]))
    tfactory = TTransport.TBufferedTransportFactory()
    pfactory = TBinaryProtocol.TBinaryProtocolFactory()

    server = TServer.TSimpleServer(processor, transport, tfactory, pfactory)

    # You could do one of these for a multithreaded server
    # server = TServer.TThreadedServer(
    #     processor, transport, tfactory, pfactory)
    # server = TServer.TThreadPoolServer(
    #     processor, transport, tfactory, pfactory)
    print('Starting the server...')
    server.serve()
    print('done.')
